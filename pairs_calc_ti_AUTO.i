! NOTE: This code is autogenerated by ti_code2.py, do not edit this file
subroutine pairs_calc_ti_linear_V0_cut1_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + b0 * &
            (bar_lambda(1,bar_i) - ti_wt_stk(1))
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + b0 * &
            (bar_lambda(1,bar_i) - ti_wt_stk(1))
        end do

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)

    ti_pot_vdw_stk(1) = ti_pot_vdw_stk(1) + (f12 - f6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(1)

          do bar_i = 1, bar_states
            bar_cont(bar_i) = bar_cont(bar_i) + (f12 - f6) * &
              (bar_lambda(1,bar_i) - ti_wt_stk(1))
          end do

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V0_cut1_mefv
subroutine pairs_calc_ti_linear_V0_cut1_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)

    ti_pot_vdw_stk(1) = ti_pot_vdw_stk(1) + (f12 - f6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(1)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V0_cut1_efv
subroutine pairs_calc_ti_linear_V0_cut1_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(1)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V0_cut1_fv
subroutine pairs_calc_ti_linear_V0_cut1_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(1)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V0_cut1_f
subroutine pairs_calc_ti_linear_V0_cut2_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + b0 * &
            (bar_lambda(1,bar_i) - ti_wt_stk(1))
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + b0 * &
            (bar_lambda(1,bar_i) - ti_wt_stk(1))
        end do

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)

    ti_pot_vdw_stk(1) = ti_pot_vdw_stk(1) + (f12 - f6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(1)

          do bar_i = 1, bar_states
            bar_cont(bar_i) = bar_cont(bar_i) + (f12 - f6) * &
              (bar_lambda(1,bar_i) - ti_wt_stk(1))
          end do

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V0_cut2_mefv
subroutine pairs_calc_ti_linear_V0_cut2_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)

    ti_pot_vdw_stk(1) = ti_pot_vdw_stk(1) + (f12 - f6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(1)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V0_cut2_efv
subroutine pairs_calc_ti_linear_V0_cut2_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(1)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V0_cut2_fv
subroutine pairs_calc_ti_linear_V0_cut2_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(1)

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(1)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V0_cut2_f
subroutine pairs_calc_ti_linear_V1_cut1_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + b0 * &
            (bar_lambda(2,bar_i) - ti_wt_stk(2))
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + b0 * &
            (bar_lambda(2,bar_i) - ti_wt_stk(2))
        end do

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)

    ti_pot_vdw_stk(2) = ti_pot_vdw_stk(2) + (f12 - f6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(2)

          do bar_i = 1, bar_states
            bar_cont(bar_i) = bar_cont(bar_i) + (f12 - f6) * &
              (bar_lambda(2,bar_i) - ti_wt_stk(2))
          end do

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V1_cut1_mefv
subroutine pairs_calc_ti_linear_V1_cut1_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)

    ti_pot_vdw_stk(2) = ti_pot_vdw_stk(2) + (f12 - f6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(2)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V1_cut1_efv
subroutine pairs_calc_ti_linear_V1_cut1_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(2)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V1_cut1_fv
subroutine pairs_calc_ti_linear_V1_cut1_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(2)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V1_cut1_f
subroutine pairs_calc_ti_linear_V1_cut2_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + b0 * &
            (bar_lambda(2,bar_i) - ti_wt_stk(2))
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + b0 * &
            (bar_lambda(2,bar_i) - ti_wt_stk(2))
        end do

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)

    ti_pot_vdw_stk(2) = ti_pot_vdw_stk(2) + (f12 - f6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(2)

          do bar_i = 1, bar_states
            bar_cont(bar_i) = bar_cont(bar_i) + (f12 - f6) * &
              (bar_lambda(2,bar_i) - ti_wt_stk(2))
          end do

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V1_cut2_mefv
subroutine pairs_calc_ti_linear_V1_cut2_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + b0

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)

    ti_pot_vdw_stk(2) = ti_pot_vdw_stk(2) + (f12 - f6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(2)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V1_cut2_efv
subroutine pairs_calc_ti_linear_V1_cut2_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(2)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V1_cut2_fv
subroutine pairs_calc_ti_linear_V1_cut2_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      df = b1 * delr2inv
      df = df * ti_wt_stk(2)

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + (12.d0*f12 - 6.d0*f6) * delr2inv * ti_wt_stk(2)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_linear_V1_cut2_f
subroutine pairs_calc_ti_sc_common_V0_cut1_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + &
        (switch * denom)
      sc_dvdl_elect_stk(1) = sc_dvdl_elect_stk(1)+&
        (switch * denom_n * scbeta * ti_signs(1)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) - &
            (switch * denom) * ti_wt_stk(1)
        end do
        do bar_i = 1, bar_states
          denom = 1.0d0 / ( delr_n + scbeta * ( 1.0d0 - &
            bar_lambda(1,bar_i) ) ) ** sceeorderinv
          bar_cont(bar_i) = bar_cont(bar_i) + (switch * denom) * &
            bar_lambda(1,bar_i)
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + &
        (switch * denom)
      sc_dvdl_elect_stk(1) = sc_dvdl_elect_stk(1)+&
        (switch * denom_n * scbeta * ti_signs(1)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) - &
            (switch * denom) * ti_wt_stk(1)
        end do
        do bar_i = 1, bar_states
          denom = 1.0d0 / ( delr_n + scbeta * ( 1.0d0 - &
            bar_lambda(1,bar_i) ) ) ** sceeorderinv
          bar_cont(bar_i) = bar_cont(bar_i) + (switch * denom) * &
            bar_lambda(1,bar_i)
        end do

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(1))+r6*ti_sigma6(ic))
    f12 = f6 * f6


    ti_pot_vdw_stk(1) = ti_pot_vdw_stk(1) + &
      ti_foureps(ic) * ( f12 - f6 ) 

    sc_dvdl_vdw_stk(1) = sc_dvdl_vdw_stk(1) + &
      ti_foureps(ic)*scalpha*ti_signs(1)*f12*(2.0d0*f6-1.0d0) 

    df = df + ti_wt_stk(1) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

          do bar_i = 1, bar_states
            bar_cont(bar_i) = bar_cont(bar_i) - &
              ti_foureps(ic) * ( f12 - f6 ) * ti_wt_stk(1)
          end do
          do bar_i = 1, bar_states
            f6 = 1.0d0 / (scalpha*(1.0d0 - bar_lambda(1,bar_i)) + &
              r6 * ti_sigma6(ic) )
            f12 = f6 * f6
            bar_cont(bar_i) = bar_cont(bar_i) + &
              ti_foureps(ic) * (f12 - f6) * bar_lambda(1,bar_i)
          end do

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V0_cut1_mefv
subroutine pairs_calc_ti_sc_common_V0_cut1_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + &
        (switch * denom)
      sc_dvdl_elect_stk(1) = sc_dvdl_elect_stk(1)+&
        (switch * denom_n * scbeta * ti_signs(1)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + &
        (switch * denom)
      sc_dvdl_elect_stk(1) = sc_dvdl_elect_stk(1)+&
        (switch * denom_n * scbeta * ti_signs(1)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(1))+r6*ti_sigma6(ic))
    f12 = f6 * f6


    ti_pot_vdw_stk(1) = ti_pot_vdw_stk(1) + &
      ti_foureps(ic) * ( f12 - f6 ) 

    sc_dvdl_vdw_stk(1) = sc_dvdl_vdw_stk(1) + &
      ti_foureps(ic)*scalpha*ti_signs(1)*f12*(2.0d0*f6-1.0d0) 

    df = df + ti_wt_stk(1) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V0_cut1_efv
subroutine pairs_calc_ti_sc_common_V0_cut1_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(1))+r6*ti_sigma6(ic))
    f12 = f6 * f6

    df = df + ti_wt_stk(1) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V0_cut1_fv
subroutine pairs_calc_ti_sc_common_V0_cut1_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(1))+r6*ti_sigma6(ic))
    f12 = f6 * f6

    df = df + ti_wt_stk(1) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V0_cut1_f
subroutine pairs_calc_ti_sc_common_V0_cut2_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + &
        (switch * denom)
      sc_dvdl_elect_stk(1) = sc_dvdl_elect_stk(1)+&
        (switch * denom_n * scbeta * ti_signs(1)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) - &
            (switch * denom) * ti_wt_stk(1)
        end do
        do bar_i = 1, bar_states
          denom = 1.0d0 / ( delr_n + scbeta * ( 1.0d0 - &
            bar_lambda(1,bar_i) ) ) ** sceeorderinv
          bar_cont(bar_i) = bar_cont(bar_i) + (switch * denom) * &
            bar_lambda(1,bar_i)
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + &
        (switch * denom)
      sc_dvdl_elect_stk(1) = sc_dvdl_elect_stk(1)+&
        (switch * denom_n * scbeta * ti_signs(1)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) - &
            (switch * denom) * ti_wt_stk(1)
        end do
        do bar_i = 1, bar_states
          denom = 1.0d0 / ( delr_n + scbeta * ( 1.0d0 - &
            bar_lambda(1,bar_i) ) ) ** sceeorderinv
          bar_cont(bar_i) = bar_cont(bar_i) + (switch * denom) * &
            bar_lambda(1,bar_i)
        end do

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(1))+r6*ti_sigma6(ic))
    f12 = f6 * f6


    ti_pot_vdw_stk(1) = ti_pot_vdw_stk(1) + &
      ti_foureps(ic) * ( f12 - f6 ) 

    sc_dvdl_vdw_stk(1) = sc_dvdl_vdw_stk(1) + &
      ti_foureps(ic)*scalpha*ti_signs(1)*f12*(2.0d0*f6-1.0d0) 

    df = df + ti_wt_stk(1) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

          do bar_i = 1, bar_states
            bar_cont(bar_i) = bar_cont(bar_i) - &
              ti_foureps(ic) * ( f12 - f6 ) * ti_wt_stk(1)
          end do
          do bar_i = 1, bar_states
            f6 = 1.0d0 / (scalpha*(1.0d0 - bar_lambda(1,bar_i)) + &
              r6 * ti_sigma6(ic) )
            f12 = f6 * f6
            bar_cont(bar_i) = bar_cont(bar_i) + &
              ti_foureps(ic) * (f12 - f6) * bar_lambda(1,bar_i)
          end do

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V0_cut2_mefv
subroutine pairs_calc_ti_sc_common_V0_cut2_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + &
        (switch * denom)
      sc_dvdl_elect_stk(1) = sc_dvdl_elect_stk(1)+&
        (switch * denom_n * scbeta * ti_signs(1)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(1) = ti_pot_elect_stk(1) + &
        (switch * denom)
      sc_dvdl_elect_stk(1) = sc_dvdl_elect_stk(1)+&
        (switch * denom_n * scbeta * ti_signs(1)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(1))+r6*ti_sigma6(ic))
    f12 = f6 * f6


    ti_pot_vdw_stk(1) = ti_pot_vdw_stk(1) + &
      ti_foureps(ic) * ( f12 - f6 ) 

    sc_dvdl_vdw_stk(1) = sc_dvdl_vdw_stk(1) + &
      ti_foureps(ic)*scalpha*ti_signs(1)*f12*(2.0d0*f6-1.0d0) 

    df = df + ti_wt_stk(1) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V0_cut2_efv
subroutine pairs_calc_ti_sc_common_V0_cut2_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(1))+r6*ti_sigma6(ic))
    f12 = f6 * f6

    df = df + ti_wt_stk(1) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V0_cut2_fv
subroutine pairs_calc_ti_sc_common_V0_cut2_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(1)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(1)

      !correct eedvir -- add contribution from softcore force

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(1))+r6*ti_sigma6(ic))
    f12 = f6 * f6

    df = df + ti_wt_stk(1) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V0_cut2_f
subroutine pairs_calc_ti_sc_common_V1_cut1_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + &
        (switch * denom)
      sc_dvdl_elect_stk(2) = sc_dvdl_elect_stk(2)+&
        (switch * denom_n * scbeta * ti_signs(2)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) - &
            (switch * denom) * ti_wt_stk(2)
        end do
        do bar_i = 1, bar_states
          denom = 1.0d0 / ( delr_n + scbeta * ( 1.0d0 - &
            bar_lambda(2,bar_i) ) ) ** sceeorderinv
          bar_cont(bar_i) = bar_cont(bar_i) + (switch * denom) * &
            bar_lambda(2,bar_i)
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + &
        (switch * denom)
      sc_dvdl_elect_stk(2) = sc_dvdl_elect_stk(2)+&
        (switch * denom_n * scbeta * ti_signs(2)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) - &
            (switch * denom) * ti_wt_stk(2)
        end do
        do bar_i = 1, bar_states
          denom = 1.0d0 / ( delr_n + scbeta * ( 1.0d0 - &
            bar_lambda(2,bar_i) ) ) ** sceeorderinv
          bar_cont(bar_i) = bar_cont(bar_i) + (switch * denom) * &
            bar_lambda(2,bar_i)
        end do

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(2))+r6*ti_sigma6(ic))
    f12 = f6 * f6


    ti_pot_vdw_stk(2) = ti_pot_vdw_stk(2) + &
      ti_foureps(ic) * ( f12 - f6 ) 

    sc_dvdl_vdw_stk(2) = sc_dvdl_vdw_stk(2) + &
      ti_foureps(ic)*scalpha*ti_signs(2)*f12*(2.0d0*f6-1.0d0) 

    df = df + ti_wt_stk(2) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

          do bar_i = 1, bar_states
            bar_cont(bar_i) = bar_cont(bar_i) - &
              ti_foureps(ic) * ( f12 - f6 ) * ti_wt_stk(2)
          end do
          do bar_i = 1, bar_states
            f6 = 1.0d0 / (scalpha*(1.0d0 - bar_lambda(2,bar_i)) + &
              r6 * ti_sigma6(ic) )
            f12 = f6 * f6
            bar_cont(bar_i) = bar_cont(bar_i) + &
              ti_foureps(ic) * (f12 - f6) * bar_lambda(2,bar_i)
          end do

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V1_cut1_mefv
subroutine pairs_calc_ti_sc_common_V1_cut1_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + &
        (switch * denom)
      sc_dvdl_elect_stk(2) = sc_dvdl_elect_stk(2)+&
        (switch * denom_n * scbeta * ti_signs(2)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + &
        (switch * denom)
      sc_dvdl_elect_stk(2) = sc_dvdl_elect_stk(2)+&
        (switch * denom_n * scbeta * ti_signs(2)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(2))+r6*ti_sigma6(ic))
    f12 = f6 * f6


    ti_pot_vdw_stk(2) = ti_pot_vdw_stk(2) + &
      ti_foureps(ic) * ( f12 - f6 ) 

    sc_dvdl_vdw_stk(2) = sc_dvdl_vdw_stk(2) + &
      ti_foureps(ic)*scalpha*ti_signs(2)*f12*(2.0d0*f6-1.0d0) 

    df = df + ti_wt_stk(2) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V1_cut1_efv
subroutine pairs_calc_ti_sc_common_V1_cut1_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(2))+r6*ti_sigma6(ic))
    f12 = f6 * f6

    df = df + ti_wt_stk(2) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V1_cut1_fv
subroutine pairs_calc_ti_sc_common_V1_cut1_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(2))+r6*ti_sigma6(ic))
    f12 = f6 * f6

    df = df + ti_wt_stk(2) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V1_cut1_f
subroutine pairs_calc_ti_sc_common_V1_cut2_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + &
        (switch * denom)
      sc_dvdl_elect_stk(2) = sc_dvdl_elect_stk(2)+&
        (switch * denom_n * scbeta * ti_signs(2)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) - &
            (switch * denom) * ti_wt_stk(2)
        end do
        do bar_i = 1, bar_states
          denom = 1.0d0 / ( delr_n + scbeta * ( 1.0d0 - &
            bar_lambda(2,bar_i) ) ) ** sceeorderinv
          bar_cont(bar_i) = bar_cont(bar_i) + (switch * denom) * &
            bar_lambda(2,bar_i)
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + &
        (switch * denom)
      sc_dvdl_elect_stk(2) = sc_dvdl_elect_stk(2)+&
        (switch * denom_n * scbeta * ti_signs(2)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) - &
            (switch * denom) * ti_wt_stk(2)
        end do
        do bar_i = 1, bar_states
          denom = 1.0d0 / ( delr_n + scbeta * ( 1.0d0 - &
            bar_lambda(2,bar_i) ) ) ** sceeorderinv
          bar_cont(bar_i) = bar_cont(bar_i) + (switch * denom) * &
            bar_lambda(2,bar_i)
        end do

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(2))+r6*ti_sigma6(ic))
    f12 = f6 * f6


    ti_pot_vdw_stk(2) = ti_pot_vdw_stk(2) + &
      ti_foureps(ic) * ( f12 - f6 ) 

    sc_dvdl_vdw_stk(2) = sc_dvdl_vdw_stk(2) + &
      ti_foureps(ic)*scalpha*ti_signs(2)*f12*(2.0d0*f6-1.0d0) 

    df = df + ti_wt_stk(2) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

          do bar_i = 1, bar_states
            bar_cont(bar_i) = bar_cont(bar_i) - &
              ti_foureps(ic) * ( f12 - f6 ) * ti_wt_stk(2)
          end do
          do bar_i = 1, bar_states
            f6 = 1.0d0 / (scalpha*(1.0d0 - bar_lambda(2,bar_i)) + &
              r6 * ti_sigma6(ic) )
            f12 = f6 * f6
            bar_cont(bar_i) = bar_cont(bar_i) + &
              ti_foureps(ic) * (f12 - f6) * bar_lambda(2,bar_i)
          end do

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V1_cut2_mefv
subroutine pairs_calc_ti_sc_common_V1_cut2_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + &
        (switch * denom)
      sc_dvdl_elect_stk(2) = sc_dvdl_elect_stk(2)+&
        (switch * denom_n * scbeta * ti_signs(2)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !cgi_cgj * delrinv          
      ti_pot_elect_stk(2) = ti_pot_elect_stk(2) + &
        (switch * denom)
      sc_dvdl_elect_stk(2) = sc_dvdl_elect_stk(2)+&
        (switch * denom_n * scbeta * ti_signs(2)) * sceeorderinv

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(2))+r6*ti_sigma6(ic))
    f12 = f6 * f6


    ti_pot_vdw_stk(2) = ti_pot_vdw_stk(2) + &
      ti_foureps(ic) * ( f12 - f6 ) 

    sc_dvdl_vdw_stk(2) = sc_dvdl_vdw_stk(2) + &
      ti_foureps(ic)*scalpha*ti_signs(2)*f12*(2.0d0*f6-1.0d0) 

    df = df + ti_wt_stk(2) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V1_cut2_efv
subroutine pairs_calc_ti_sc_common_V1_cut2_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
      eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(2))+r6*ti_sigma6(ic))
    f12 = f6 * f6

    df = df + ti_wt_stk(2) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V1_cut2_fv
subroutine pairs_calc_ti_sc_common_V1_cut2_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv

      delr_n = delr ** (sceeorder)

      denom = 1.0d0 / ( delr_n + scbeta * &
        (1.0d0 - ti_wt_stk(2)) ) ** sceeorderinv
      denom_n = denom ** ( 1 + sceeorder )
          
      switch = cgi_cgj * switch          

      !b0 - b1 = cgi_cgj * d_switch_dx * dxdr
      df = - ((b0 - b1) * denom * delrinv) + &
        (switch * denom_n * delr_n * delr2inv)
      df = df * ti_wt_stk(2)

      !correct eedvir -- add contribution from softcore force

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2 * delr2 * delr2
    f6 = 1.0d0/(scalpha*(1.0d0-ti_wt_stk(2))+r6*ti_sigma6(ic))
    f12 = f6 * f6

    df = df + ti_wt_stk(2) * ti_foureps(ic) * delr2 * delr2 * f12 * &
      ti_sigma6(ic) * (12.0d0 * f6 - 6.0d0)

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_common_V1_cut2_f
subroutine pairs_calc_ti_sc_sc_V0_cut1_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(1) = &
         ti_pot_elect_stk(1) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(1) = &
         sc_elect_stk(1) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + (b0 - cgi_cgj * delrinv) * &
            (bar_lambda(1,bar_i)-ti_wt_stk(1))
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(1) = &
         ti_pot_elect_stk(1) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(1) = &
         sc_elect_stk(1) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + (b0 - cgi_cgj * delrinv) * &
            (bar_lambda(1,bar_i)-ti_wt_stk(1))
        end do

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    sc_vdw_stk(1) = sc_vdw_stk(1) + ( f12 - f6 )
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V0_cut1_mefv
subroutine pairs_calc_ti_sc_sc_V0_cut1_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(1) = &
         ti_pot_elect_stk(1) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(1) = &
         sc_elect_stk(1) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(1) = &
         ti_pot_elect_stk(1) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(1) = &
         sc_elect_stk(1) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    sc_vdw_stk(1) = sc_vdw_stk(1) + ( f12 - f6 )
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V0_cut1_efv
subroutine pairs_calc_ti_sc_sc_V0_cut1_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V0_cut1_fv
subroutine pairs_calc_ti_sc_sc_V0_cut1_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V0_cut1_f
subroutine pairs_calc_ti_sc_sc_V0_cut2_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(1) = &
         ti_pot_elect_stk(1) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(1) = &
         sc_elect_stk(1) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + (b0 - cgi_cgj * delrinv) * &
            (bar_lambda(1,bar_i)-ti_wt_stk(1))
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(1) = &
         ti_pot_elect_stk(1) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(1) = &
         sc_elect_stk(1) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + (b0 - cgi_cgj * delrinv) * &
            (bar_lambda(1,bar_i)-ti_wt_stk(1))
        end do

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    sc_vdw_stk(1) = sc_vdw_stk(1) + ( f12 - f6 )
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V0_cut2_mefv
subroutine pairs_calc_ti_sc_sc_V0_cut2_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(1) = &
         ti_pot_elect_stk(1) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(1) = &
         sc_elect_stk(1) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(1) = &
         ti_pot_elect_stk(1) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(1) = &
         sc_elect_stk(1) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    sc_vdw_stk(1) = sc_vdw_stk(1) + ( f12 - f6 )
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V0_cut2_efv
subroutine pairs_calc_ti_sc_sc_V0_cut2_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(1) = eedvir_stk_sc(1) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V0_cut2_fv
subroutine pairs_calc_ti_sc_sc_V0_cut2_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(1)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(1, 1, img_j) = &
        ti_img_frc(1, 1, img_j) + dfx
      ti_img_frc(1, 2, img_j) = &
        ti_img_frc(1, 2, img_j) + dfy
      ti_img_frc(1, 3, img_j) = &
        ti_img_frc(1, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(1, 1, img_i) = ti_img_frc(1, 1, img_i) - dumx
  ti_img_frc(1, 2, img_i) = ti_img_frc(1, 2, img_i) - dumy
  ti_img_frc(1, 3, img_i) = ti_img_frc(1, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V0_cut2_f
subroutine pairs_calc_ti_sc_sc_V1_cut1_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(2) = &
         ti_pot_elect_stk(2) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(2) = &
         sc_elect_stk(2) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + (b0 - cgi_cgj * delrinv) * &
            (bar_lambda(2,bar_i)-ti_wt_stk(2))
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(2) = &
         ti_pot_elect_stk(2) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(2) = &
         sc_elect_stk(2) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + (b0 - cgi_cgj * delrinv) * &
            (bar_lambda(2,bar_i)-ti_wt_stk(2))
        end do

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    sc_vdw_stk(2) = sc_vdw_stk(2) + ( f12 - f6 )
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V1_cut1_mefv
subroutine pairs_calc_ti_sc_sc_V1_cut1_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(2) = &
         ti_pot_elect_stk(2) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(2) = &
         sc_elect_stk(2) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(2) = &
         ti_pot_elect_stk(2) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(2) = &
         sc_elect_stk(2) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    sc_vdw_stk(2) = sc_vdw_stk(2) + ( f12 - f6 )
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V1_cut1_efv
subroutine pairs_calc_ti_sc_sc_V1_cut1_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V1_cut1_fv
subroutine pairs_calc_ti_sc_sc_V1_cut1_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
    if (delr2 .lt. max_nb_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V1_cut1_f
subroutine pairs_calc_ti_sc_sc_V1_cut2_mefv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(2) = &
         ti_pot_elect_stk(2) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(2) = &
         sc_elect_stk(2) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + (b0 - cgi_cgj * delrinv) * &
            (bar_lambda(2,bar_i)-ti_wt_stk(2))
        end do
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(2) = &
         ti_pot_elect_stk(2) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(2) = &
         sc_elect_stk(2) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

        do bar_i = 1, bar_states
          bar_cont(bar_i) = bar_cont(bar_i) + (b0 - cgi_cgj * delrinv) * &
            (bar_lambda(2,bar_i)-ti_wt_stk(2))
        end do

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    sc_vdw_stk(2) = sc_vdw_stk(2) + ( f12 - f6 )
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V1_cut2_mefv
subroutine pairs_calc_ti_sc_sc_V1_cut2_efv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(2) = &
         ti_pot_elect_stk(2) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(2) = &
         sc_elect_stk(2) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

       ! remove the reciprocal contribution from the main energy array          
       ti_pot_elect_stk(2) = &
         ti_pot_elect_stk(2) + b0 - cgi_cgj * delrinv

       ! add the full non-switched coulomb pot to the softcore energy array
       sc_elect_stk(2) = &
         sc_elect_stk(2) + cgi_cgj * delrinv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    sc_vdw_stk(2) = sc_vdw_stk(2) + ( f12 - f6 )
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V1_cut2_efv
subroutine pairs_calc_ti_sc_sc_V1_cut2_fv(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
    eedvir_stk_sc(2) = eedvir_stk_sc(2) - df * delr2

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      vxx = vxx - delx * dfx
      vxy = vxy - delx * dfy
      vxz = vxz - delx * dfz
      vyy = vyy - dely * dfy
      vyz = vyz - dely * dfz
      vzz = vzz - delz * dfz

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V1_cut2_fv
subroutine pairs_calc_ti_sc_sc_V1_cut2_f(img_crd, img_qterm, ef_tbl, & 
eed_cub, ico, ipairs_sublst, img_iac, cn1, cn2, x_tran)

  implicit none

! Formal arguments:

  double precision, intent(in)  :: img_crd(3, *)
  double precision, intent(in)  :: img_qterm(*)
  double precision, intent(in)  :: ef_tbl(*) ! For simplicity we call it ef_tbl always
  double precision, intent(in)  :: eed_cub(*)
  integer, intent(in)           :: ico(*)
  integer, intent(inout)        :: ipairs_sublst(*)
  integer, intent(in)           :: img_iac(*)
  double precision, intent(in)  :: cn1(*), cn2(*)

  double precision, intent(in)  :: x_tran(1:3, 0:17)

! Local variables:

  integer, parameter            :: mask27 = Z"07FFFFFF"
  double precision, parameter   :: half = 1.d0/2.d0
  double precision, parameter   :: third = 1.d0/3.d0

  double precision      :: dumx, dumy, dumz

  double precision      :: cgi
  double precision      :: cgi_cgj
  double precision      :: b0, b1
  double precision      :: df
  double precision      :: dfx, dfy, dfz
  double precision      :: f6, r6, f12

  double precision      :: du, du2, du3 ! 'u' is another name for delr2
  double precision      :: del_efs
  double precision      :: dens_efs
  double precision      :: lowest_efs_u

  ! Variables used with erfc switch table; name are historical:

  double precision      :: switch
  double precision      :: d_switch_dx
  double precision      :: x, dx, e3dx, e4dx2
  double precision      :: delr, delrinv

  ! For softcore electrostatics
  double precision      :: denom, denom_n, delr_n

  integer               :: iaci
  integer               :: ic
  integer               :: ind
  integer               :: nxt_img_j, img_j
  integer               :: itran
  integer               :: sublst_idx
  integer               :: saved_pairlist_val

  double precision      :: nxt_delx, nxt_dely, nxt_delz
  double precision      :: delx, dely, delz, delr2, delr2inv

  dens_efs = efs_tbl_dens
  del_efs = 1.d0 / dens_efs
  lowest_efs_u = lowest_efs_delr2
  
! First loop over the ee evaluation-only pairs:

  dumx = 0.d0
  dumy = 0.d0
  dumz = 0.d0

  cgi = img_qterm(img_i)

  ! The pairlist must have one dummy end entry to cover reading past the
  ! end of the list...

  saved_pairlist_val = ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1)

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = &
    ipairs_sublst(ee_eval_cnt + full_eval_cnt)

  if (common_tran .eq. 1) then
    nxt_img_j = ipairs_sublst(1)
    itran = 13
  else
    nxt_img_j = iand(ipairs_sublst(1), mask27)
    itran = ishft(ipairs_sublst(1), -27)
  end if

  nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
  nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
  nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

  do sublst_idx = 2, ee_eval_cnt + 1

    img_j = nxt_img_j
    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz
     if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      real_j = img_atm_map(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2
      
      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv
     
      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz


    end if

  end do

  iaci = ntypes_stk * (img_iac(img_i) - 1)

  do sublst_idx = ee_eval_cnt + 2, ee_eval_cnt + full_eval_cnt + 1

    img_j = nxt_img_j

    real_j = img_atm_map(img_j)

    delx = nxt_delx
    dely = nxt_dely
    delz = nxt_delz

    if (common_tran .eq. 1) then
      nxt_img_j = ipairs_sublst(sublst_idx)
      itran = 13
    else
      nxt_img_j = iand(ipairs_sublst(sublst_idx), mask27)
      itran = ishft(ipairs_sublst(sublst_idx), -27)
    end if

    nxt_delx = img_crd(1, nxt_img_j) + x_tran(1, itran)
    nxt_dely = img_crd(2, nxt_img_j) + x_tran(2, itran)
    nxt_delz = img_crd(3, nxt_img_j) + x_tran(3, itran)

    delr2 = delx * delx + dely * dely + delz * delz

    if (delr2 .lt. max_nb_cut2) then

      ic = ico(iaci + img_iac(img_j))
      if (delr2 .lt. es_cut2) then


      cgi_cgj = cgi * img_qterm(img_j)

      ! Do the Coulomb part of the direct sum using erfc spline table: 

      delr = sqrt(delr2)
      delrinv = 1.d0 / delr

      x = dxdr * delr
      ind = int(eedtbdns_stk * x)
      dx = x - dble(ind) * del
      ind = ishft(ind, 2)             ! 4 * ind

      e3dx  = dx * eed_cub(3 + ind)
      e4dx2 = dx * dx *  eed_cub(4 + ind)

      switch = eed_cub(1 + ind) + &
               dx * (eed_cub(2 + ind) + half * (e3dx + third * e4dx2))

      d_switch_dx = eed_cub(2 + ind) + e3dx + half * e4dx2

      b0 = cgi_cgj * delrinv * switch
      b1 = (b0 - cgi_cgj * d_switch_dx * dxdr)

      delr2inv = delrinv * delrinv
      df = b1 * delr2inv

      !remove reciprocal contribution (which has been scaled by ti_wt_stk)
      df = (df - cgi_cgj * delrinv * delr2inv) * &
        ti_wt_stk(2)

      !add full electrostatic contribution 
      df = df + cgi_cgj * delrinv * delr2inv

      else
        delr2inv = 1.d0 / delr2
        df = 0.d0
      end if

    r6 = delr2inv * delr2inv * delr2inv
    f6 = cn2(ic) * r6
    f12 = cn1(ic) * (r6 * r6)
    df = df + ( 12.0d0 * f12 - 6.0d0 * f6 ) * delr2inv

      dfx = delx * df
      dfy = dely * df
      dfz = delz * df

      dumx = dumx + dfx
      dumy = dumy + dfy
      dumz = dumz + dfz

      ti_img_frc(2, 1, img_j) = &
        ti_img_frc(2, 1, img_j) + dfx
      ti_img_frc(2, 2, img_j) = &
        ti_img_frc(2, 2, img_j) + dfy
      ti_img_frc(2, 3, img_j) = &
        ti_img_frc(2, 3, img_j) + dfz
    end if
  end do

  ti_img_frc(2, 1, img_i) = ti_img_frc(2, 1, img_i) - dumx
  ti_img_frc(2, 2, img_i) = ti_img_frc(2, 2, img_i) - dumy
  ti_img_frc(2, 3, img_i) = ti_img_frc(2, 3, img_i) - dumz

  ipairs_sublst(ee_eval_cnt + full_eval_cnt + 1) = saved_pairlist_val

  return
end subroutine pairs_calc_ti_sc_sc_V1_cut2_f
